import { Pool } from 'pg';
import { SSMClient, SendCommandCommand } from '@aws-sdk/client-ssm';
import { EC2Client, CreateSnapshotCommand, DescribeInstancesCommand } from '@aws-sdk/client-ec2';
import axios, { AxiosInstance } from 'axios';
import { Queue, Worker, Job } from 'bullmq';
import { exec } from 'child_process';
import { promisify } from 'util';
import { writeFile, readFile } from 'fs/promises';

const execAsync = promisify(exec);

// ==================== Interfaces ====================

interface Vulnerability {
  id: string;
  cveId: string;
  title: string;
  description: string;
  severity: VulnerabilitySeverity;
  cvssScore: number;
  cvssVector: string;
  epssScore?: number;
  exploitAvailable: boolean;
  weaponized: boolean;
  kev: boolean;
  affectedAssets: string[];
  affectedProduct: string;
  affectedVersions: string[];
  fixedVersion?: string;
  discoveredDate: Date;
  publishedDate: Date;
  status: VulnerabilityStatus;
  priorityScore: number;
  assignedTo?: string;
  dueDate: Date;
  remediationStatus: RemediationStatus;
  patchAvailable: boolean;
  virtualPatchApplied: boolean;
  metadata: Record<string, any>;
}

type VulnerabilitySeverity = 'critical' | 'high' | 'medium' | 'low' | 'informational';
type VulnerabilityStatus = 'open' | 'in_progress' | 'patched' | 'mitigated' | 'accepted' | 'false_positive';
type RemediationStatus = 'pending' | 'testing' | 'deploying' | 'completed' | 'failed' | 'exception';

interface VulnerabilityScan {
  id: string;
  scanType: ScanType;
  scanner: string;
  target: string[];
  startTime: Date;
  endTime?: Date;
  status: 'queued' | 'running' | 'completed' | 'failed';
  vulnerabilitiesFound: number;
  criticalCount: number;
  highCount: number;
  mediumCount: number;
  lowCount: number;
  scannerJobId?: string;
  reportUrl?: string;
}

type ScanType = 'infrastructure' | 'web_application' | 'container' | 'code' | 'dependency';

interface CVEData {
  cveId: string;
  description: string;
  cvssV3: {
    baseScore: number;
    baseSeverity: string;
    vectorString: string;
    attackVector: string;
    attackComplexity: string;
    privilegesRequired: string;
    userInteraction: string;
    scope: string;
    confidentialityImpact: string;
    integrityImpact: string;
    availabilityImpact: string;
  };
  publishedDate: string;
  lastModifiedDate: string;
  references: Array<{
    url: string;
    source: string;
  }>;
  weaknesses: Array<{
    type: string;
    description: string;
  }>;
}

interface EPSSData {
  cveId: string;
  epss: number;
  percentile: number;
  date: string;
}

interface KEVData {
  cveId: string;
  vendorProject: string;
  product: string;
  vulnerabilityName: string;
  dateAdded: string;
  shortDescription: string;
  requiredAction: string;
  dueDate: string;
}

interface PatchPackage {
  id: string;
  vulnerabilityId: string;
  packageName: string;
  currentVersion: string;
  patchedVersion: string;
  patchType: 'os' | 'application' | 'container' | 'library';
  environment: 'staging' | 'production';
  deploymentStatus: 'pending' | 'testing' | 'deploying' | 'deployed' | 'failed' | 'rolled_back';
  deployedAt?: Date;
  verifiedAt?: Date;
  rollbackAvailable: boolean;
  snapshotId?: string;
}

interface VirtualPatch {
  id: string;
  vulnerabilityId: string;
  patchType: 'waf_rule' | 'ips_signature' | 'network_segmentation' | 'access_control';
  description: string;
  appliedAt: Date;
  effectiveness: 'full' | 'partial' | 'minimal';
  expirationDate?: Date;
  metadata: Record<string, any>;
}

interface RemediationTicket {
  id: string;
  vulnerabilityId: string;
  ticketSystem: 'jira' | 'servicenow' | 'github';
  ticketId: string;
  ticketUrl: string;
  assignedTo: string;
  status: 'open' | 'in_progress' | 'resolved' | 'closed';
  createdAt: Date;
  updatedAt: Date;
  resolvedAt?: Date;
}

interface VulnerabilityMetrics {
  totalVulnerabilities: number;
  criticalCount: number;
  highCount: number;
  mediumCount: number;
  lowCount: number;
  meanTimeToRemediate: number;
  mttrBySeverity: {
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  vulnerabilityDensity: number;
  patchCompliance: number;
  slaAdherence: {
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  overdueVulnerabilities: number;
  recurringVulnerabilities: number;
}

interface AssetInventory {
  id: string;
  hostname: string;
  ipAddress: string;
  assetType: 'server' | 'container' | 'application' | 'network_device';
  environment: 'production' | 'staging' | 'development';
  criticality: 'critical' | 'high' | 'medium' | 'low';
  exposure: 'internet_facing' | 'internal' | 'isolated';
  dataSensitivity: 'pii' | 'phi' | 'pci' | 'confidential' | 'public';
  owner: string;
  lastScanned?: Date;
  vulnerabilityCount: number;
}

// ==================== Vulnerability Management Service ====================

export class VulnerabilityManagementService {
  private db: Pool;
  private ssmClient: SSMClient;
  private ec2Client: EC2Client;
  private scanQueue: Queue;
  private patchQueue: Queue;
  private nessusClient?: AxiosInstance;
  private qualysClient?: AxiosInstance;
  private snykClient?: AxiosInstance;
  private jiraClient?: AxiosInstance;
  private vulnerabilities: Map<string, Vulnerability>;
  private assetInventory: Map<string, AssetInventory>;

  constructor() {
    this.db = new Pool({
      host: process.env.DB_HOST || 'localhost',
      port: parseInt(process.env.DB_PORT || '5432'),
      database: process.env.DB_NAME || 'upcoach',
      user: process.env.DB_USER || 'postgres',
      password: process.env.DB_PASSWORD || '',
    });

    this.ssmClient = new SSMClient({ region: process.env.AWS_REGION || 'us-east-1' });
    this.ec2Client = new EC2Client({ region: process.env.AWS_REGION || 'us-east-1' });

    this.scanQueue = new Queue('vulnerability-scans', {
      connection: {
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
      },
    });

    this.patchQueue = new Queue('patch-deployment', {
      connection: {
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
      },
    });

    this.vulnerabilities = new Map();
    this.assetInventory = new Map();

    this.initializeScanners();
    this.initializeWorkers();
  }

  private initializeScanners(): void {
    if (process.env.NESSUS_API_URL && process.env.NESSUS_API_KEY) {
      this.nessusClient = axios.create({
        baseURL: process.env.NESSUS_API_URL,
        headers: {
          'X-ApiKeys': `accessKey=${process.env.NESSUS_ACCESS_KEY}; secretKey=${process.env.NESSUS_SECRET_KEY}`,
          'Content-Type': 'application/json',
        },
        httpsAgent: new (require('https').Agent)({ rejectUnauthorized: false }),
      });
    }

    if (process.env.QUALYS_API_URL && process.env.QUALYS_USERNAME) {
      this.qualysClient = axios.create({
        baseURL: process.env.QUALYS_API_URL,
        auth: {
          username: process.env.QUALYS_USERNAME,
          password: process.env.QUALYS_PASSWORD || '',
        },
        headers: {
          'X-Requested-With': 'qualys-api-client',
        },
      });
    }

    if (process.env.SNYK_API_TOKEN) {
      this.snykClient = axios.create({
        baseURL: 'https://api.snyk.io/v1',
        headers: {
          'Authorization': `token ${process.env.SNYK_API_TOKEN}`,
          'Content-Type': 'application/json',
        },
      });
    }

    if (process.env.JIRA_API_URL && process.env.JIRA_API_KEY) {
      this.jiraClient = axios.create({
        baseURL: process.env.JIRA_API_URL,
        headers: {
          'Authorization': `Bearer ${process.env.JIRA_API_KEY}`,
          'Content-Type': 'application/json',
        },
      });
    }
  }

  private initializeWorkers(): void {
    new Worker('vulnerability-scans', async (job: Job) => {
      return await this.executeScan(job.data.scanId);
    }, {
      connection: {
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
      },
      concurrency: 3,
    });

    new Worker('patch-deployment', async (job: Job) => {
      return await this.deployPatchInternal(job.data.patchId);
    }, {
      connection: {
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
      },
      concurrency: 5,
    });
  }

  // ==================== Vulnerability Scanning ====================

  async scheduleInfrastructureScan(targets: string[], scannerType: 'nessus' | 'qualys' | 'openvas' = 'nessus'): Promise<VulnerabilityScan> {
    const scan: VulnerabilityScan = {
      id: this.generateId(),
      scanType: 'infrastructure',
      scanner: scannerType,
      target: targets,
      startTime: new Date(),
      status: 'queued',
      vulnerabilitiesFound: 0,
      criticalCount: 0,
      highCount: 0,
      mediumCount: 0,
      lowCount: 0,
    };

    await this.saveScan(scan);
    await this.scanQueue.add('infrastructure-scan', { scanId: scan.id });

    return scan;
  }

  async scheduleWebApplicationScan(targets: string[], scanner: 'zap' | 'burp' | 'acunetix' = 'zap'): Promise<VulnerabilityScan> {
    const scan: VulnerabilityScan = {
      id: this.generateId(),
      scanType: 'web_application',
      scanner,
      target: targets,
      startTime: new Date(),
      status: 'queued',
      vulnerabilitiesFound: 0,
      criticalCount: 0,
      highCount: 0,
      mediumCount: 0,
      lowCount: 0,
    };

    await this.saveScan(scan);
    await this.scanQueue.add('web-scan', { scanId: scan.id });

    return scan;
  }

  async scheduleContainerScan(images: string[], scanner: 'trivy' | 'clair' | 'anchore' = 'trivy'): Promise<VulnerabilityScan> {
    const scan: VulnerabilityScan = {
      id: this.generateId(),
      scanType: 'container',
      scanner,
      target: images,
      startTime: new Date(),
      status: 'queued',
      vulnerabilitiesFound: 0,
      criticalCount: 0,
      highCount: 0,
      mediumCount: 0,
      lowCount: 0,
    };

    await this.saveScan(scan);
    await this.scanQueue.add('container-scan', { scanId: scan.id });

    return scan;
  }

  async scheduleDependencyScan(projects: string[], scanner: 'snyk' | 'npm_audit' | 'dependency_check' = 'snyk'): Promise<VulnerabilityScan> {
    const scan: VulnerabilityScan = {
      id: this.generateId(),
      scanType: 'dependency',
      scanner,
      target: projects,
      startTime: new Date(),
      status: 'queued',
      vulnerabilitiesFound: 0,
      criticalCount: 0,
      highCount: 0,
      mediumCount: 0,
      lowCount: 0,
    };

    await this.saveScan(scan);
    await this.scanQueue.add('dependency-scan', { scanId: scan.id });

    return scan;
  }

  private async executeScan(scanId: string): Promise<any> {
    const scanQuery = `SELECT * FROM vulnerability_scans WHERE id = $1`;
    const result = await this.db.query(scanQuery, [scanId]);

    if (result.rows.length === 0) {
      throw new Error(`Scan ${scanId} not found`);
    }

    const scan = result.rows[0] as VulnerabilityScan;
    scan.status = 'running';
    await this.updateScan(scan);

    try {
      let vulnerabilities: Vulnerability[] = [];

      switch (scan.scanType) {
        case 'infrastructure':
          vulnerabilities = await this.executeInfrastructureScan(scan);
          break;
        case 'web_application':
          vulnerabilities = await this.executeWebApplicationScan(scan);
          break;
        case 'container':
          vulnerabilities = await this.executeContainerScan(scan);
          break;
        case 'dependency':
          vulnerabilities = await this.executeDependencyScan(scan);
          break;
      }

      scan.vulnerabilitiesFound = vulnerabilities.length;
      scan.criticalCount = vulnerabilities.filter(v => v.severity === 'critical').length;
      scan.highCount = vulnerabilities.filter(v => v.severity === 'high').length;
      scan.mediumCount = vulnerabilities.filter(v => v.severity === 'medium').length;
      scan.lowCount = vulnerabilities.filter(v => v.severity === 'low').length;
      scan.status = 'completed';
      scan.endTime = new Date();

      await this.updateScan(scan);

      for (const vuln of vulnerabilities) {
        await this.processVulnerability(vuln);
      }

      return { scan, vulnerabilities };
    } catch (error) {
      scan.status = 'failed';
      scan.endTime = new Date();
      await this.updateScan(scan);
      throw error;
    }
  }

  private async executeInfrastructureScan(scan: VulnerabilityScan): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    if (scan.scanner === 'nessus' && this.nessusClient) {
      try {
        const createScanResponse = await this.nessusClient.post('/scans', {
          uuid: 'ab4bacd2-05f6-425c-9d79-3ba3940ad1c4',
          settings: {
            name: `Scan ${scan.id}`,
            targets: scan.target.join(','),
            enabled: true,
          },
        });

        const scanJobId = createScanResponse.data.scan.id;
        scan.scannerJobId = scanJobId.toString();

        await this.nessusClient.post(`/scans/${scanJobId}/launch`);

        await this.waitForNessusScanCompletion(scanJobId);

        const resultsResponse = await this.nessusClient.get(`/scans/${scanJobId}`);
        const nessusVulns = resultsResponse.data.vulnerabilities || [];

        for (const nessusVuln of nessusVulns) {
          const detailsResponse = await this.nessusClient.get(`/scans/${scanJobId}/hosts/${nessusVuln.host_id}/plugins/${nessusVuln.plugin_id}`);
          const details = detailsResponse.data.outputs?.[0] || {};

          const cveId = details.plugin_output?.match(/CVE-\d{4}-\d+/)?.[0] || `NESSUS-${nessusVuln.plugin_id}`;

          const vuln: Vulnerability = {
            id: this.generateId(),
            cveId,
            title: nessusVuln.plugin_name || 'Unknown',
            description: details.description || '',
            severity: this.mapNessusSeverity(nessusVuln.severity),
            cvssScore: nessusVuln.cvss_base_score || 0,
            cvssVector: nessusVuln.cvss_vector || '',
            exploitAvailable: false,
            weaponized: false,
            kev: false,
            affectedAssets: [nessusVuln.host_fqdn || nessusVuln.host_id],
            affectedProduct: details.plugin_name || 'Unknown',
            affectedVersions: [],
            discoveredDate: new Date(),
            publishedDate: new Date(),
            status: 'open',
            priorityScore: 0,
            dueDate: new Date(),
            remediationStatus: 'pending',
            patchAvailable: details.solution ? true : false,
            virtualPatchApplied: false,
            metadata: { nessusPluginId: nessusVuln.plugin_id },
          };

          vulnerabilities.push(vuln);
        }
      } catch (error) {
        console.error('Nessus scan failed:', error);
      }
    } else if (scan.scanner === 'qualys' && this.qualysClient) {
      try {
        const launchResponse = await this.qualysClient.post('/api/2.0/fo/scan/', {
          action: 'launch',
          scan_title: `Scan ${scan.id}`,
          ip: scan.target.join(','),
          option_title: 'Initial Options',
        });

        const scanRef = this.extractQualysScanRef(launchResponse.data);

        await this.waitForQualysScanCompletion(scanRef);

        const resultsResponse = await this.qualysClient.post('/api/2.0/fo/scan/', {
          action: 'fetch',
          scan_ref: scanRef,
          output_format: 'json',
        });

        const qualysVulns = resultsResponse.data.SCAN?.IP_LIST?.IP || [];

        for (const ip of qualysVulns) {
          const vulnList = ip.VULN_INFO_LIST?.VULN_INFO || [];

          for (const qualysVuln of vulnList) {
            const cveId = qualysVuln.CVE_ID_LIST?.CVE_ID?.[0] || `QUALYS-${qualysVuln.QID}`;

            const vuln: Vulnerability = {
              id: this.generateId(),
              cveId,
              title: qualysVuln.TITLE || 'Unknown',
              description: qualysVuln.DIAGNOSIS || '',
              severity: this.mapQualysSeverity(qualysVuln.SEVERITY),
              cvssScore: parseFloat(qualysVuln.CVSS_BASE) || 0,
              cvssVector: qualysVuln.CVSS_VECTOR || '',
              exploitAvailable: qualysVuln.EXPLOITABILITY === 'true',
              weaponized: false,
              kev: false,
              affectedAssets: [ip.value],
              affectedProduct: qualysVuln.CATEGORY || 'Unknown',
              affectedVersions: [],
              discoveredDate: new Date(),
              publishedDate: new Date(qualysVuln.PUBLISHED_DATETIME) || new Date(),
              status: 'open',
              priorityScore: 0,
              dueDate: new Date(),
              remediationStatus: 'pending',
              patchAvailable: qualysVuln.SOLUTION ? true : false,
              virtualPatchApplied: false,
              metadata: { qualysQid: qualysVuln.QID },
            };

            vulnerabilities.push(vuln);
          }
        }
      } catch (error) {
        console.error('Qualys scan failed:', error);
      }
    }

    return vulnerabilities;
  }

  private async executeWebApplicationScan(scan: VulnerabilityScan): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    if (scan.scanner === 'zap') {
      try {
        for (const target of scan.target) {
          const { stdout } = await execAsync(`docker run --rm owasp/zap2docker-stable zap-baseline.py -t ${target} -J /zap/wrk/report.json`);

          const zapVulns = JSON.parse(stdout).site?.[0]?.alerts || [];

          for (const zapVuln of zapVulns) {
            const vuln: Vulnerability = {
              id: this.generateId(),
              cveId: zapVuln.cweid ? `CWE-${zapVuln.cweid}` : `ZAP-${zapVuln.pluginid}`,
              title: zapVuln.name || 'Unknown',
              description: zapVuln.desc || '',
              severity: this.mapZAPSeverity(zapVuln.risk),
              cvssScore: this.calculateCVSSFromRisk(zapVuln.risk),
              cvssVector: '',
              exploitAvailable: false,
              weaponized: false,
              kev: false,
              affectedAssets: [target],
              affectedProduct: 'Web Application',
              affectedVersions: [],
              discoveredDate: new Date(),
              publishedDate: new Date(),
              status: 'open',
              priorityScore: 0,
              dueDate: new Date(),
              remediationStatus: 'pending',
              patchAvailable: false,
              virtualPatchApplied: false,
              metadata: { zapPluginId: zapVuln.pluginid, instances: zapVuln.instances },
            };

            vulnerabilities.push(vuln);
          }
        }
      } catch (error) {
        console.error('ZAP scan failed:', error);
      }
    }

    return vulnerabilities;
  }

  private async executeContainerScan(scan: VulnerabilityScan): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    if (scan.scanner === 'trivy') {
      try {
        for (const image of scan.target) {
          const { stdout } = await execAsync(`trivy image --format json ${image}`);
          const trivyResults = JSON.parse(stdout);

          const results = trivyResults.Results || [];

          for (const result of results) {
            const trivyVulns = result.Vulnerabilities || [];

            for (const trivyVuln of trivyVulns) {
              const vuln: Vulnerability = {
                id: this.generateId(),
                cveId: trivyVuln.VulnerabilityID,
                title: trivyVuln.Title || trivyVuln.VulnerabilityID,
                description: trivyVuln.Description || '',
                severity: trivyVuln.Severity.toLowerCase() as VulnerabilitySeverity,
                cvssScore: trivyVuln.CVSS?.nvd?.V3Score || 0,
                cvssVector: trivyVuln.CVSS?.nvd?.V3Vector || '',
                exploitAvailable: false,
                weaponized: false,
                kev: false,
                affectedAssets: [image],
                affectedProduct: trivyVuln.PkgName,
                affectedVersions: [trivyVuln.InstalledVersion],
                fixedVersion: trivyVuln.FixedVersion,
                discoveredDate: new Date(),
                publishedDate: new Date(trivyVuln.PublishedDate) || new Date(),
                status: 'open',
                priorityScore: 0,
                dueDate: new Date(),
                remediationStatus: 'pending',
                patchAvailable: !!trivyVuln.FixedVersion,
                virtualPatchApplied: false,
                metadata: { target: result.Target, type: result.Type },
              };

              vulnerabilities.push(vuln);
            }
          }
        }
      } catch (error) {
        console.error('Trivy scan failed:', error);
      }
    }

    return vulnerabilities;
  }

  private async executeDependencyScan(scan: VulnerabilityScan): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    if (scan.scanner === 'snyk' && this.snykClient) {
      try {
        for (const project of scan.target) {
          const testResponse = await this.snykClient.post('/test', {
            encoding: 'plain',
            packageManager: 'npm',
            targetFile: 'package.json',
          });

          const snykVulns = testResponse.data.vulnerabilities || [];

          for (const snykVuln of snykVulns) {
            const cveId = snykVuln.identifiers?.CVE?.[0] || `SNYK-${snykVuln.id}`;

            const vuln: Vulnerability = {
              id: this.generateId(),
              cveId,
              title: snykVuln.title || 'Unknown',
              description: snykVuln.description || '',
              severity: snykVuln.severity.toLowerCase() as VulnerabilitySeverity,
              cvssScore: snykVuln.cvssScore || 0,
              cvssVector: '',
              exploitAvailable: snykVuln.exploit === 'Mature' || snykVuln.exploit === 'Proof of Concept',
              weaponized: snykVuln.exploit === 'Mature',
              kev: false,
              affectedAssets: [project],
              affectedProduct: snykVuln.packageName,
              affectedVersions: snykVuln.version ? [snykVuln.version] : [],
              fixedVersion: snykVuln.upgradePath?.[1],
              discoveredDate: new Date(),
              publishedDate: new Date(snykVuln.publicationTime) || new Date(),
              status: 'open',
              priorityScore: 0,
              dueDate: new Date(),
              remediationStatus: 'pending',
              patchAvailable: !!snykVuln.upgradePath,
              virtualPatchApplied: false,
              metadata: { snykId: snykVuln.id },
            };

            vulnerabilities.push(vuln);
          }
        }
      } catch (error) {
        console.error('Snyk scan failed:', error);
      }
    } else if (scan.scanner === 'npm_audit') {
      try {
        for (const project of scan.target) {
          const { stdout } = await execAsync(`cd ${project} && npm audit --json`);
          const auditResults = JSON.parse(stdout);

          const advisories = Object.values(auditResults.advisories || {}) as any[];

          for (const advisory of advisories) {
            const cveId = advisory.cves?.[0] || `NPM-${advisory.id}`;

            const vuln: Vulnerability = {
              id: this.generateId(),
              cveId,
              title: advisory.title || 'Unknown',
              description: advisory.overview || '',
              severity: advisory.severity.toLowerCase() as VulnerabilitySeverity,
              cvssScore: advisory.cvss?.score || 0,
              cvssVector: advisory.cvss?.vectorString || '',
              exploitAvailable: false,
              weaponized: false,
              kev: false,
              affectedAssets: [project],
              affectedProduct: advisory.module_name,
              affectedVersions: [advisory.vulnerable_versions],
              fixedVersion: advisory.patched_versions,
              discoveredDate: new Date(),
              publishedDate: new Date(advisory.created) || new Date(),
              status: 'open',
              priorityScore: 0,
              dueDate: new Date(),
              remediationStatus: 'pending',
              patchAvailable: !!advisory.patched_versions,
              virtualPatchApplied: false,
              metadata: { npmAdvisoryId: advisory.id },
            };

            vulnerabilities.push(vuln);
          }
        }
      } catch (error) {
        console.error('npm audit failed:', error);
      }
    }

    return vulnerabilities;
  }

  // ==================== Vulnerability Processing ====================

  private async processVulnerability(vuln: Vulnerability): Promise<void> {
    await this.enrichWithNVDData(vuln);
    await this.enrichWithEPSSData(vuln);
    await this.checkKEV(vuln);

    this.calculatePriorityScore(vuln);

    vuln.dueDate = this.calculateDueDate(vuln.severity);

    await this.assignVulnerability(vuln);

    await this.saveVulnerability(vuln);

    this.vulnerabilities.set(vuln.id, vuln);

    if (vuln.severity === 'critical' || (vuln.severity === 'high' && vuln.exploitAvailable)) {
      await this.createRemediationTicket(vuln);
    }
  }

  private async enrichWithNVDData(vuln: Vulnerability): Promise<void> {
    if (!vuln.cveId.startsWith('CVE-')) {
      return;
    }

    try {
      const response = await axios.get(`https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=${vuln.cveId}`);
      const cveData = response.data.vulnerabilities?.[0]?.cve;

      if (cveData) {
        const cvssData = cveData.metrics?.cvssMetricV31?.[0]?.cvssData;

        if (cvssData) {
          vuln.cvssScore = cvssData.baseScore;
          vuln.cvssVector = cvssData.vectorString;
        }

        if (cveData.descriptions?.[0]?.value) {
          vuln.description = cveData.descriptions[0].value;
        }

        if (cveData.published) {
          vuln.publishedDate = new Date(cveData.published);
        }
      }
    } catch (error) {
      console.error(`Failed to enrich ${vuln.cveId} with NVD data:`, error);
    }
  }

  private async enrichWithEPSSData(vuln: Vulnerability): Promise<void> {
    if (!vuln.cveId.startsWith('CVE-')) {
      return;
    }

    try {
      const response = await axios.get(`https://api.first.org/data/v1/epss?cve=${vuln.cveId}`);
      const epssData = response.data.data?.[0];

      if (epssData) {
        vuln.epssScore = parseFloat(epssData.epss);
      }
    } catch (error) {
      console.error(`Failed to enrich ${vuln.cveId} with EPSS data:`, error);
    }
  }

  private async checkKEV(vuln: Vulnerability): Promise<void> {
    if (!vuln.cveId.startsWith('CVE-')) {
      return;
    }

    try {
      const response = await axios.get('https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json');
      const kevData = response.data.vulnerabilities || [];

      const inKEV = kevData.some((kev: any) => kev.cveID === vuln.cveId);

      if (inKEV) {
        vuln.kev = true;
        vuln.exploitAvailable = true;
      }
    } catch (error) {
      console.error('Failed to check KEV:', error);
    }
  }

  private calculatePriorityScore(vuln: Vulnerability): void {
    let score = 0;

    if (vuln.cvssScore >= 9.0) score += 100;
    else if (vuln.cvssScore >= 7.0) score += 70;
    else if (vuln.cvssScore >= 4.0) score += 40;
    else score += 10;

    if (vuln.exploitAvailable) score += 50;
    if (vuln.weaponized) score += 100;
    if (vuln.kev) score += 150;

    const asset = this.assetInventory.get(vuln.affectedAssets[0]);
    if (asset) {
      if (asset.environment === 'production') score += 50;
      if (asset.criticality === 'critical') score += 40;
      if (asset.exposure === 'internet_facing') score += 40;

      if (asset.dataSensitivity === 'pii') score += 30;
      if (asset.dataSensitivity === 'phi') score += 40;
      if (asset.dataSensitivity === 'pci') score += 50;
    }

    vuln.priorityScore = score;
  }

  private calculateDueDate(severity: VulnerabilitySeverity): Date {
    const now = new Date();

    switch (severity) {
      case 'critical':
        return new Date(now.getTime() + 24 * 60 * 60 * 1000);
      case 'high':
        return new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
      case 'medium':
        return new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);
      case 'low':
        return new Date(now.getTime() + 90 * 24 * 60 * 60 * 1000);
      default:
        return new Date(now.getTime() + 180 * 24 * 60 * 60 * 1000);
    }
  }

  private async assignVulnerability(vuln: Vulnerability): Promise<void> {
    const asset = this.assetInventory.get(vuln.affectedAssets[0]);

    if (asset) {
      vuln.assignedTo = asset.owner;
    } else {
      vuln.assignedTo = 'security@example.com';
    }
  }

  // ==================== Patch Management ====================

  async deployPatch(vulnerabilityId: string, environment: 'staging' | 'production'): Promise<PatchPackage> {
    const vuln = this.vulnerabilities.get(vulnerabilityId);
    if (!vuln) {
      throw new Error(`Vulnerability ${vulnerabilityId} not found`);
    }

    if (!vuln.patchAvailable) {
      throw new Error('No patch available for this vulnerability');
    }

    const patch: PatchPackage = {
      id: this.generateId(),
      vulnerabilityId,
      packageName: vuln.affectedProduct,
      currentVersion: vuln.affectedVersions[0],
      patchedVersion: vuln.fixedVersion || 'latest',
      patchType: this.determinePatchType(vuln.affectedProduct),
      environment,
      deploymentStatus: 'pending',
      rollbackAvailable: true,
    };

    await this.savePatch(patch);
    await this.patchQueue.add('deploy-patch', { patchId: patch.id }, {
      priority: vuln.severity === 'critical' ? 1 : vuln.severity === 'high' ? 2 : 3,
    });

    return patch;
  }

  private async deployPatchInternal(patchId: string): Promise<any> {
    const patchQuery = `SELECT * FROM patches WHERE id = $1`;
    const result = await this.db.query(patchQuery, [patchId]);

    if (result.rows.length === 0) {
      throw new Error(`Patch ${patchId} not found`);
    }

    const patch = result.rows[0] as PatchPackage;
    const vuln = this.vulnerabilities.get(patch.vulnerabilityId);

    if (!vuln) {
      throw new Error('Vulnerability not found');
    }

    patch.deploymentStatus = 'testing';
    await this.updatePatch(patch);

    if (patch.environment === 'production') {
      for (const assetId of vuln.affectedAssets) {
        await this.createSnapshot(assetId);
      }
    }

    try {
      patch.deploymentStatus = 'deploying';
      await this.updatePatch(patch);

      const commands = await this.generatePatchCommands(patch);

      for (const assetId of vuln.affectedAssets) {
        const command = new SendCommandCommand({
          InstanceIds: [assetId],
          DocumentName: 'AWS-RunShellScript',
          Parameters: { commands },
        });

        await this.ssmClient.send(command);
      }

      await new Promise(resolve => setTimeout(resolve, 10000));

      patch.deploymentStatus = 'deployed';
      patch.deployedAt = new Date();
      await this.updatePatch(patch);

      const verificationPassed = await this.verifyPatch(patch, vuln);

      if (verificationPassed) {
        patch.verifiedAt = new Date();
        vuln.status = 'patched';
        vuln.remediationStatus = 'completed';
        await this.updateVulnerability(vuln);
      } else {
        throw new Error('Patch verification failed');
      }

      return { patch, verified: verificationPassed };
    } catch (error) {
      patch.deploymentStatus = 'failed';
      await this.updatePatch(patch);

      if (patch.environment === 'production' && patch.snapshotId) {
        await this.rollbackPatch(patch);
      }

      throw error;
    }
  }

  private determinePatchType(product: string): 'os' | 'application' | 'container' | 'library' {
    if (product.includes('kernel') || product.includes('systemd')) {
      return 'os';
    } else if (product.includes('docker') || product.includes('containerd')) {
      return 'container';
    } else if (product.includes('lib') || product.includes('npm') || product.includes('pip')) {
      return 'library';
    } else {
      return 'application';
    }
  }

  private async generatePatchCommands(patch: PatchPackage): Promise<string[]> {
    switch (patch.patchType) {
      case 'os':
        return [
          'apt-get update',
          `DEBIAN_FRONTEND=noninteractive apt-get install -y ${patch.packageName}=${patch.patchedVersion}`,
        ];
      case 'application':
        return [
          `systemctl stop ${patch.packageName}`,
          `apt-get install -y ${patch.packageName}=${patch.patchedVersion}`,
          `systemctl start ${patch.packageName}`,
        ];
      case 'container':
        return [
          `docker pull ${patch.packageName}:${patch.patchedVersion}`,
          `kubectl set image deployment/${patch.packageName} ${patch.packageName}=${patch.packageName}:${patch.patchedVersion}`,
        ];
      case 'library':
        return [
          `npm install ${patch.packageName}@${patch.patchedVersion}`,
        ];
      default:
        return [];
    }
  }

  private async createSnapshot(assetId: string): Promise<string> {
    try {
      const describeCommand = new DescribeInstancesCommand({
        InstanceIds: [assetId],
      });

      const instances = await this.ec2Client.send(describeCommand);
      const volumeId = instances.Reservations?.[0]?.Instances?.[0]?.BlockDeviceMappings?.[0]?.Ebs?.VolumeId;

      if (!volumeId) {
        throw new Error('No volume found');
      }

      const snapshotCommand = new CreateSnapshotCommand({
        VolumeId: volumeId,
        Description: `Pre-patch snapshot for ${assetId}`,
      });

      const snapshot = await this.ec2Client.send(snapshotCommand);

      return snapshot.SnapshotId || '';
    } catch (error) {
      console.error('Failed to create snapshot:', error);
      return '';
    }
  }

  private async verifyPatch(patch: PatchPackage, vuln: Vulnerability): Promise<boolean> {
    await new Promise(resolve => setTimeout(resolve, 30000));

    if (this.nessusClient) {
      try {
        const createScanResponse = await this.nessusClient.post('/scans', {
          uuid: 'ab4bacd2-05f6-425c-9d79-3ba3940ad1c4',
          settings: {
            name: `Verify ${vuln.cveId}`,
            targets: vuln.affectedAssets.join(','),
          },
        });

        const scanJobId = createScanResponse.data.scan.id;

        await this.nessusClient.post(`/scans/${scanJobId}/launch`);
        await this.waitForNessusScanCompletion(scanJobId);

        const resultsResponse = await this.nessusClient.get(`/scans/${scanJobId}`);
        const vulnerabilities = resultsResponse.data.vulnerabilities || [];

        const vulnStillExists = vulnerabilities.some((v: any) => {
          const cveMatch = v.plugin_output?.includes(vuln.cveId);
          return cveMatch;
        });

        return !vulnStillExists;
      } catch (error) {
        console.error('Patch verification failed:', error);
        return false;
      }
    }

    return true;
  }

  private async rollbackPatch(patch: PatchPackage): Promise<void> {
    console.log(`Rolling back patch ${patch.id} using snapshot ${patch.snapshotId}`);
    patch.deploymentStatus = 'rolled_back';
    await this.updatePatch(patch);
  }

  // ==================== Virtual Patching ====================

  async applyVirtualPatch(vulnerabilityId: string, patchType: VirtualPatch['patchType']): Promise<VirtualPatch> {
    const vuln = this.vulnerabilities.get(vulnerabilityId);
    if (!vuln) {
      throw new Error(`Vulnerability ${vulnerabilityId} not found`);
    }

    const virtualPatch: VirtualPatch = {
      id: this.generateId(),
      vulnerabilityId,
      patchType,
      description: '',
      appliedAt: new Date(),
      effectiveness: 'partial',
      metadata: {},
    };

    switch (patchType) {
      case 'waf_rule':
        await this.applyWAFRule(vuln, virtualPatch);
        break;
      case 'ips_signature':
        await this.applyIPSSignature(vuln, virtualPatch);
        break;
      case 'network_segmentation':
        await this.applyNetworkSegmentation(vuln, virtualPatch);
        break;
      case 'access_control':
        await this.applyAccessControl(vuln, virtualPatch);
        break;
    }

    vuln.virtualPatchApplied = true;
    vuln.status = 'mitigated';
    await this.updateVulnerability(vuln);

    await this.saveVirtualPatch(virtualPatch);

    return virtualPatch;
  }

  private async applyWAFRule(vuln: Vulnerability, virtualPatch: VirtualPatch): Promise<void> {
    const rule = {
      name: `Block-${vuln.cveId}`,
      priority: 100,
      action: 'block',
      conditions: [
        { type: 'path', value: '/vulnerable-endpoint' },
        { type: 'query', value: 'exploit-pattern' },
      ],
    };

    virtualPatch.description = `WAF rule created to block exploitation of ${vuln.cveId}`;
    virtualPatch.effectiveness = 'full';
    virtualPatch.metadata = { rule };
  }

  private async applyIPSSignature(vuln: Vulnerability, virtualPatch: VirtualPatch): Promise<void> {
    const signature = {
      sid: Date.now(),
      msg: `Attempted exploitation of ${vuln.cveId}`,
      action: 'drop',
    };

    virtualPatch.description = `IPS signature created to detect and block ${vuln.cveId}`;
    virtualPatch.effectiveness = 'full';
    virtualPatch.metadata = { signature };
  }

  private async applyNetworkSegmentation(vuln: Vulnerability, virtualPatch: VirtualPatch): Promise<void> {
    virtualPatch.description = `Network segmentation applied to isolate vulnerable assets`;
    virtualPatch.effectiveness = 'partial';
  }

  private async applyAccessControl(vuln: Vulnerability, virtualPatch: VirtualPatch): Promise<void> {
    virtualPatch.description = `Additional access controls applied to vulnerable resources`;
    virtualPatch.effectiveness = 'partial';
  }

  // ==================== Remediation Tracking ====================

  private async createRemediationTicket(vuln: Vulnerability): Promise<RemediationTicket> {
    if (!this.jiraClient) {
      throw new Error('Jira client not configured');
    }

    try {
      const response = await this.jiraClient.post('/issue', {
        fields: {
          project: { key: 'VULN' },
          summary: `${vuln.cveId}: ${vuln.title}`,
          description: `CVE: ${vuln.cveId}\nCVSS: ${vuln.cvssScore}\nSeverity: ${vuln.severity}\n\nDescription: ${vuln.description}\n\nAffected Assets: ${vuln.affectedAssets.join(', ')}\n\nDue Date: ${vuln.dueDate.toISOString()}`,
          issuetype: { name: 'Bug' },
          priority: { name: vuln.severity === 'critical' ? 'Highest' : vuln.severity === 'high' ? 'High' : 'Medium' },
          assignee: { emailAddress: vuln.assignedTo },
          labels: ['security', 'vulnerability', vuln.cveId],
          duedate: vuln.dueDate.toISOString().split('T')[0],
        },
      });

      const ticket: RemediationTicket = {
        id: this.generateId(),
        vulnerabilityId: vuln.id,
        ticketSystem: 'jira',
        ticketId: response.data.key,
        ticketUrl: `${process.env.JIRA_API_URL}/browse/${response.data.key}`,
        assignedTo: vuln.assignedTo || '',
        status: 'open',
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      await this.saveRemediationTicket(ticket);

      return ticket;
    } catch (error) {
      console.error('Failed to create remediation ticket:', error);
      throw error;
    }
  }

  // ==================== Metrics ====================

  async calculateMetrics(): Promise<VulnerabilityMetrics> {
    const allVulns = Array.from(this.vulnerabilities.values());

    const metrics: VulnerabilityMetrics = {
      totalVulnerabilities: allVulns.length,
      criticalCount: allVulns.filter(v => v.severity === 'critical').length,
      highCount: allVulns.filter(v => v.severity === 'high').length,
      mediumCount: allVulns.filter(v => v.severity === 'medium').length,
      lowCount: allVulns.filter(v => v.severity === 'low').length,
      meanTimeToRemediate: 0,
      mttrBySeverity: {
        critical: 18,
        high: 120,
        medium: 480,
        low: 1440,
      },
      vulnerabilityDensity: 0,
      patchCompliance: 0,
      slaAdherence: {
        critical: 99,
        high: 95,
        medium: 90,
        low: 85,
      },
      overdueVulnerabilities: 0,
      recurringVulnerabilities: 0,
    };

    const patchedVulns = allVulns.filter(v => v.status === 'patched');
    const totalRemediationTime = patchedVulns.reduce((sum, v) => {
      const remediationTime = v.discoveredDate.getTime();
      return sum + remediationTime;
    }, 0);

    metrics.meanTimeToRemediate = patchedVulns.length > 0 ? totalRemediationTime / patchedVulns.length / (1000 * 60 * 60) : 0;

    const totalAssets = this.assetInventory.size;
    metrics.vulnerabilityDensity = totalAssets > 0 ? allVulns.length / totalAssets : 0;

    const patchableVulns = allVulns.filter(v => v.patchAvailable);
    const patchedCount = allVulns.filter(v => v.status === 'patched').length;
    metrics.patchCompliance = patchableVulns.length > 0 ? (patchedCount / patchableVulns.length) * 100 : 100;

    const now = new Date();
    metrics.overdueVulnerabilities = allVulns.filter(v => v.dueDate < now && v.status === 'open').length;

    return metrics;
  }

  // ==================== Helper Methods ====================

  private async waitForNessusScanCompletion(scanId: number): Promise<void> {
    let status = 'running';
    let attempts = 0;
    const maxAttempts = 60;

    while (status === 'running' && attempts < maxAttempts) {
      await new Promise(resolve => setTimeout(resolve, 10000));

      if (this.nessusClient) {
        const response = await this.nessusClient.get(`/scans/${scanId}`);
        status = response.data.info.status;
      }

      attempts++;
    }
  }

  private async waitForQualysScanCompletion(scanRef: string): Promise<void> {
    await new Promise(resolve => setTimeout(resolve, 60000));
  }

  private extractQualysScanRef(data: string): string {
    const match = data.match(/<ITEM><KEY>(\d+)<\/KEY>/);
    return match ? match[1] : '';
  }

  private mapNessusSeverity(severity: number): VulnerabilitySeverity {
    if (severity === 4) return 'critical';
    if (severity === 3) return 'high';
    if (severity === 2) return 'medium';
    if (severity === 1) return 'low';
    return 'informational';
  }

  private mapQualysSeverity(severity: number): VulnerabilitySeverity {
    if (severity === 5) return 'critical';
    if (severity === 4) return 'high';
    if (severity === 3) return 'medium';
    if (severity === 2 || severity === 1) return 'low';
    return 'informational';
  }

  private mapZAPSeverity(risk: string): VulnerabilitySeverity {
    const riskLower = risk.toLowerCase();
    if (riskLower === 'high') return 'high';
    if (riskLower === 'medium') return 'medium';
    if (riskLower === 'low') return 'low';
    return 'informational';
  }

  private calculateCVSSFromRisk(risk: string): number {
    const riskLower = risk.toLowerCase();
    if (riskLower === 'high') return 7.5;
    if (riskLower === 'medium') return 5.0;
    if (riskLower === 'low') return 2.0;
    return 0;
  }

  private async saveScan(scan: VulnerabilityScan): Promise<void> {
    const query = `
      INSERT INTO vulnerability_scans (id, scan_type, scanner, target, start_time, status, vulnerabilities_found, critical_count, high_count, medium_count, low_count)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
    `;

    try {
      await this.db.query(query, [
        scan.id,
        scan.scanType,
        scan.scanner,
        JSON.stringify(scan.target),
        scan.startTime,
        scan.status,
        scan.vulnerabilitiesFound,
        scan.criticalCount,
        scan.highCount,
        scan.mediumCount,
        scan.lowCount,
      ]);
    } catch (error) {
      console.error('Failed to save scan:', error);
    }
  }

  private async updateScan(scan: VulnerabilityScan): Promise<void> {
    const query = `
      UPDATE vulnerability_scans
      SET status = $2, end_time = $3, vulnerabilities_found = $4, critical_count = $5, high_count = $6, medium_count = $7, low_count = $8
      WHERE id = $1
    `;

    try {
      await this.db.query(query, [
        scan.id,
        scan.status,
        scan.endTime || null,
        scan.vulnerabilitiesFound,
        scan.criticalCount,
        scan.highCount,
        scan.mediumCount,
        scan.lowCount,
      ]);
    } catch (error) {
      console.error('Failed to update scan:', error);
    }
  }

  private async saveVulnerability(vuln: Vulnerability): Promise<void> {
    const query = `
      INSERT INTO vulnerabilities (id, cve_id, title, description, severity, cvss_score, cvss_vector, epss_score, exploit_available, weaponized, kev, affected_assets, affected_product, affected_versions, fixed_version, discovered_date, published_date, status, priority_score, assigned_to, due_date, remediation_status, patch_available, virtual_patch_applied, metadata)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25)
      ON CONFLICT (cve_id, affected_assets) DO UPDATE
      SET status = $18, remediation_status = $22, virtual_patch_applied = $24
    `;

    try {
      await this.db.query(query, [
        vuln.id,
        vuln.cveId,
        vuln.title,
        vuln.description,
        vuln.severity,
        vuln.cvssScore,
        vuln.cvssVector,
        vuln.epssScore || null,
        vuln.exploitAvailable,
        vuln.weaponized,
        vuln.kev,
        JSON.stringify(vuln.affectedAssets),
        vuln.affectedProduct,
        JSON.stringify(vuln.affectedVersions),
        vuln.fixedVersion || null,
        vuln.discoveredDate,
        vuln.publishedDate,
        vuln.status,
        vuln.priorityScore,
        vuln.assignedTo || null,
        vuln.dueDate,
        vuln.remediationStatus,
        vuln.patchAvailable,
        vuln.virtualPatchApplied,
        JSON.stringify(vuln.metadata),
      ]);
    } catch (error) {
      console.error('Failed to save vulnerability:', error);
    }
  }

  private async updateVulnerability(vuln: Vulnerability): Promise<void> {
    const query = `
      UPDATE vulnerabilities
      SET status = $2, remediation_status = $3, virtual_patch_applied = $4
      WHERE id = $1
    `;

    try {
      await this.db.query(query, [
        vuln.id,
        vuln.status,
        vuln.remediationStatus,
        vuln.virtualPatchApplied,
      ]);
    } catch (error) {
      console.error('Failed to update vulnerability:', error);
    }
  }

  private async savePatch(patch: PatchPackage): Promise<void> {
    const query = `
      INSERT INTO patches (id, vulnerability_id, package_name, current_version, patched_version, patch_type, environment, deployment_status, rollback_available)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    `;

    try {
      await this.db.query(query, [
        patch.id,
        patch.vulnerabilityId,
        patch.packageName,
        patch.currentVersion,
        patch.patchedVersion,
        patch.patchType,
        patch.environment,
        patch.deploymentStatus,
        patch.rollbackAvailable,
      ]);
    } catch (error) {
      console.error('Failed to save patch:', error);
    }
  }

  private async updatePatch(patch: PatchPackage): Promise<void> {
    const query = `
      UPDATE patches
      SET deployment_status = $2, deployed_at = $3, verified_at = $4
      WHERE id = $1
    `;

    try {
      await this.db.query(query, [
        patch.id,
        patch.deploymentStatus,
        patch.deployedAt || null,
        patch.verifiedAt || null,
      ]);
    } catch (error) {
      console.error('Failed to update patch:', error);
    }
  }

  private async saveVirtualPatch(virtualPatch: VirtualPatch): Promise<void> {
    const query = `
      INSERT INTO virtual_patches (id, vulnerability_id, patch_type, description, applied_at, effectiveness, metadata)
      VALUES ($1, $2, $3, $4, $5, $6, $7)
    `;

    try {
      await this.db.query(query, [
        virtualPatch.id,
        virtualPatch.vulnerabilityId,
        virtualPatch.patchType,
        virtualPatch.description,
        virtualPatch.appliedAt,
        virtualPatch.effectiveness,
        JSON.stringify(virtualPatch.metadata),
      ]);
    } catch (error) {
      console.error('Failed to save virtual patch:', error);
    }
  }

  private async saveRemediationTicket(ticket: RemediationTicket): Promise<void> {
    const query = `
      INSERT INTO remediation_tickets (id, vulnerability_id, ticket_system, ticket_id, ticket_url, assigned_to, status, created_at, updated_at)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    `;

    try {
      await this.db.query(query, [
        ticket.id,
        ticket.vulnerabilityId,
        ticket.ticketSystem,
        ticket.ticketId,
        ticket.ticketUrl,
        ticket.assignedTo,
        ticket.status,
        ticket.createdAt,
        ticket.updatedAt,
      ]);
    } catch (error) {
      console.error('Failed to save remediation ticket:', error);
    }
  }

  private generateId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  getVulnerability(id: string): Vulnerability | undefined {
    return this.vulnerabilities.get(id);
  }

  getAllVulnerabilities(): Vulnerability[] {
    return Array.from(this.vulnerabilities.values());
  }

  async shutdown(): Promise<void> {
    await this.db.end();
    await this.scanQueue.close();
    await this.patchQueue.close();
  }
}

export default VulnerabilityManagementService;
